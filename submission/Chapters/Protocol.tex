\chapter{The mpOTR Protocol}
\label{chapters:protocol}

\section{Properties of private conversations}
Following the conventions of the OTR protocol, the term "private" is used to describe the properties of casual real-life conversations. The following four properties are both required in two-party as well as multi-party private conversations:
\begin{description}
\item[Confidentiality] No one else apart from the chat room participants can read the messages exchanged.
\item[Authentication] You are assured that the participants are who you think they are.
\item[Repudiation] The messages sent do not have digital signatures that are checkable by a third party. Anyone can forge messages after a conversation to make them look like they came from you. However, during a conversation, other participants are assured the messages they see are authentic and unmodified. 
\item[Forward secrecy] If you lose control of your private keys, no previous conversation is compromised.
\end{description}

In the context of the multi-party chat room, one more property is required:
\begin{description}
\item[Chat room transcript consistency] All participants share the same view over the messages exchanged in a given chat room.
\end{description}


\section{High level protocol overview}
\begin{algorithm}[H]
  \label{algorithms:mpotr_algo}
  \KwIn{$\mathcal{P}$ : participants list}
  \KwResult{Executes a run of the mpOTR protocol}
  \Begin{

    $sid$ := Offer($\mathcal{P}$)
    
    $\mathcal{S}$ := DSKE($sid$, $\mathcal{P}$)
    
    $\mathcal{K}$ := GKA($sid$, $\mathcal{S}$, $\mathcal{P}$)
    
    $\mathcal{A}$ := Attest($sid$, $\mathcal{S}$, $\mathcal{P}$)
    
    \If{$\mathcal{A}$ $\neq$ "OK"}{
      \Return{"Error"}
    }

    $\mathcal{T}$ := Communication($sid$, $\mathcal{K}$, $\mathcal{S}$, $\mathcal{P}$)
  
    $c$ := Shutdown($sid$, $\mathcal{T}$, $\mathcal{S}$, $\mathcal{P}$)
    
    \If{$c$ = "consensus"}{
      \Return{"OK"}
    }
    \Else{
      \Return{"Error"}
    }
  }
  \caption{The mpOTR protocol}
\end{algorithm}

In Algorithm \ref{algorithms:mpotr_algo} we illustrate high-level overview of the protocol. The whole protocol has been divided into sequential phases, which we call sub-protocols. The first four of them (Offer, DSKE GKA and Attest) are responsible for setting up all the needed parameters, for the private communication to take place. The Communication sub-protocol is the one that governs the actual private group conversation. Finally, the Shutdown sub-protocol is responsible for every action that needs to be done before ending each private session. We briefly describe the function of each sub-protocol below.

During the Offer sub-protocol, the participants create a Session ID, $sid$. This is a unique (with high probability) number identifying the session. The Offer sub-protocol is described in more detail in section \ref{subsections:offer}. 

During the DSKE sub-protocol, each participant creates an association table $\mathcal{S}$ which maps each participant to the signing key he is going to use for this session. Each participant generates an ephemeral signing key, that she will be using in order to sign her messages during this session. This way she ensures her messages are authenticated. Then, every participant exchanges their ephemeral signing keys with every other participant, using a Deniable Authenticated Key Exchange (DAKE) algorithm. When all exchanges have taken place, every participant has created $\mathcal{S}$. The ephemeral signing keys to be used in this session are deniable. The DSKE sub-protocol and the DAKE are described in more detail in section \ref{subsections:DSKE}.

During the GKA sub-protocol, the participants generate a shared key $\mathcal{K}$ that will be used to derive encryption keys. The derived keys, in turn, will be used to encrypt the messages during this session. The GKA sub-protocol is described in more detail in section \ref{subsections:gka}

During the Attest sub-protocol, the participants authenticate $sid$ and ensure that they agree on $\mathcal{S}$. The Attest sub-protocol is described in more detail in section \ref{subsections:attest}. 

During the Communication sub-protocol, the actual private conversation takes place. The users use $\mathcal{K}$, ephemeral signing keys, and $\mathcal{S}$, in order to encrypt and authenticate their messages. When this phase is finished, a transcript of the chat room $\mathcal{T}$ is returned, which contains all the messages of the chatroom, by participant. The Communication sub-protocol is described in more detail in section \ref{subsections:communication}. 

During the Shutdown sub-protocol, the participants determine if $\mathcal{T}$ is consistent, and reveal their ephemeral signing keys. If the transcript is indeed consistent we say that consensus has been reached. The revelation of the ephemeral signing keys adds to the deniability property of the protocol, in the same manner the key revelation in OTR protocol does. However, itâ€™s an optional feature, since the signing keys are deniable in the first place. The Shutdown sub-protocol is described in more detail in section \ref{subsections:shutdown}. 


\section{Sub-protocols}

\subsection{Offer}
\label{subsections:offer}
During the first phase of the setup procedure, which we call "Offer", the participants calculate a unique Session ID, called $sid_i$. This is a value that will be used to distinguish the current session between other sessions created by the same set of participants.

Each participant $\hat{X}$ chooses a random 256-bit value $x_{\hat{X}}$, which is his contribution to the $sid_i$. We define $sid_i$ as the SHA-512 hash of the serialized ordered list that contains every participant's contribution.

Each offer message contains the sender's contribution along with his position in the participants list.

The participant who wants to initiate the mpOTR protocol, broadcasts an offer message. Once a participant receives an offer message:

\begin{itemize}
	\item[]He checks if the sender's position contained in the message matches his actual position, if not, he rejects the message.

	\item[]He checks if he has already received an offer message from the sender, if so, he rejects the message.

	\item[]He checks if he has already broadcast his own offer message. If not, creates and broadcasts his own offer message.

	\item[]He checks if he has received every participant's contribution. If so, he calculates the $sid_i$ and proceeds to the next setup phase.
\end{itemize}

Notice that offer messages are not authenticated and hence $sid_i$ must
be verified \emph{after} the participants have exchanged signing keys, as described in section \ref{subsections:attest}.


\subsection{Deniable Signature Key Exchange (DSKE)}
\label{subsections:DSKE}
In \cite{mpotr} a construction for a DSKE is proposed:

Given a deniable Authenticated Key Exchange (denAKE), two participants of the chat can generate a deniable and authenticated shared secret. With that secret they can exchange their ephemeral signing public key in an encrypted and authenticated fashion, using symmetric algorithms. This is done for every pair of participants. After that, they will all have created an association table $\mathcal{S}$, which associates each participant with their signing key.

Afterwards, the participants must make sure that they all have constructed the same $\mathcal{S}$, as described in section \ref{subsections:attest}.

\subsubsection{denAKE}
In \cite{mpotr} no denAKE is specified. We propose the following protocol:

\begin{itemize}

	\item[] Each participant generates a private/public Diffie-Hellman keypair $(A_i, g^{A_i})$, which will be used as a longterm key to idenitfy him to other participants. This
is done only once, when a member first used the protocol, then the key remains
the same for subsequent runs of the protocol.

	\item[] To initiate a denAKE, each participant creates an ephemeral Diffie-Hellman keypair
		$(a_i,g^{a_i})$ used only in this run of the protocol (he uses however the same ephemeral key
		to communicate with all the participants).

	\item[] Then he broadcasts the public components of the longterm and ephemeral keys to
		all chat participants in the tuple $(g^{A_i}, g^{a_i})$. We shall call this
		message a "Handshake Message".

	\item[] When participant $i$ has received a handshake Message $(g^{A_j}, g^{a_j})$ from some
		other participant $j$, she can compute the shared secret, as specified by the triple
		Diffie-Hellman protocol. This secret is $g^{a_ia_j} || g^{A_ia_j} || g^{A_ja_i}$
		.

	\item[] After computing the shared secret she encrypts and mac's a magic number and sends it
		to the other party. This is done to verify that the other party has indeed generated
		the same shared secret and is not an adversary trying to break the forward secrecy
		property of triple Diffie-Hellman, see \ref{confirm_message_explain}. We shall call
		this message a "Confirm Message".

	\item[] When she herself has received the corresponding Confirm Message she is assured that
		the shared secret can be safely used and there is no foul play. Now she
		encrypts-then-macs her signing public key and sends it to the other party. This
		message is called a "Key Message"


	\item[] When a key message is received she first verifies the message using the same mac.
		If the tag checks out she decrypts the key and adds it in the association table $\mathcal{S}$.
\end{itemize}

In figure \ref{den_ake_schematic} a schematic description of the protocol is provided.

\paragraph{Order of the concatenation}
When the shared secret is calculated, three values must be concatenated. Since
concatenation is not commutative the two parties must agree on the order that the
concatenation happens.

This is achieved by compare the values $g^{A_i}$ and $g^{A_j}$. If
$g^{A_i} \le g^{A_j}$ then the shared secret is $g^{a_ia_j} || g^{A_ia_j} || g^{A_ja_i}$
If not then the shared secret is $g^{a_ia_j} || g^{A_ja_i} || g^{A_ia_j}$. That is, the
value that is generated using the highest public key takes precedence during the
concatenation.

In the overview of the algorithm above, it was silently assumed that
$g^{A_i} \le g^{A_j}$.

\paragraph{The need of a confirmation message}
\label{confirm_message_explain}
A confirmation message is needed if want to have forward secrecy in this exchange.
We must make sure that we are really speaking with the intended participant. Consider
the following scenario.

An adversary, Eve, creates an ephemeral keypair $(b, g^b)$. Then he poses as Bob to Alice,
and broadcasts a handshake message containing $(g^B,g^b)$ where $g^B$ is Bob's
public longterm key.

After Alice receives the handshake message she can construct the shared secret. Eve
however cannot construct the secret since she does not know Bob's longterm
private key. If Alice starts sending data before confirming that the other party
has indeed arrived at the same secret she is under the danger to lose the forward
secrecy property for all messages she sends with the secret.

Indeed the only reason Eve can't construct the secret that Alice calculated, is
that she doesn't have Bob's longterm private key. This of course means that if
she somehow gets a hold of this key, she can decrypt some messages. This situation
of course does not satisfy the forward secrecy property.


\paragraph{Properties}
Triple Diffie-Hellman is a protocol that is a) authenticated b) forward secret
and c) deniable.

It is authenticated, because the shared secret can only be calculated by someone
only if he posses one of the longterm private keys (and the corresponding ephemeral
of course).

It is forward secret, because once the ephemeral key has been destroyed, it is
impossible to reconstruct the shared secret even when the longterm
private key is compromised.

It is deniable, because the only values that are exchanged during a protocol run
are the two public keys that a participant will use. Nothing is signed, which means
that nothing can be used to prove that someone took part in a conversation.

Another property of this protocol that comes for free is its very fast key generation
as, basically, any random number can be used as a secret key.

Thus Triple Diffie-Hellman satisfies the properties required in \cite{mpotr} and
can be used as a denAKE.

\begin{figure}[t]
  \fbox{%
    \pseudocode{%
      \textbf{Alice} \< \< \textbf{Bob} \\[][\hline]
      \text{ Choose a random number $x \in Z_p^*$ }\< \< \\
      \< \sendmessageright*{Send \ \left(g^x,g^X\right)} \< \\
      \< \< \text{ Choose a random number $y \in Z_p^*$ } \\
      \< \< s = g^{xy} || g^{Xy} || g^{Yx} \\
      \< \< k_1 = KDF_1(s) \\
      \< \< k_2=KDF_2(s) \\
      \< \sendmessageleft*{Send \ \left(g^y,g^Y\right)} \< \\
      s = g^{xy} || g^{Xy} || g^{Yx} \< \< \\
      k_1 = KDF_1(s) \< \< \\
      k_2 = KDF_2(s) \< \< \\
      \< \sendmessageright*{ Send \\ c = AES_{k_1}("confirm") \\ MAC_{k_2}(c)\ } \< \\
      \< \< \text{Verify mac} \\
      \< \< m = AES^{-1}_{k_1}(c) \\
      \< \< \text{Verify m = "confirm"} \\
      \< \sendmessageleft*{ Send \\ c = AES_{k_1}("confirm") \\ MAC_{k_2}(c)\ } \< \\
      \text{Verify mac} \< \< \\
      m = AES^{-1}_{k_1}(c) \< \< \\
      \text{Verify m = "confirm"} \\
      \< \sendmessageright*{Send \\ c = AES_{k_1}(\pk_a) \\ MAC_{k_2}(c) } \< \\
      \< \< \text{Verify mac} \\
      \< \< \text{Add $\pk_a$ to association table} \\
      \< \sendmessageleft*{Send \\ c = AES_{k_1}(\pk_b) \\ MAC_{k_2}(c) } \< \\
      \text{Verify mac} \< \<  \\
      \text{Add $\pk_b$ to association table} \< \< \\
    }
  }
  \caption{The denAKE protocol, where $X$ and $Y$ are the private parts of the long term keys}
  \label{den_ake_schematic}
\end{figure}

\clearpage
\subsection{Group Key Agreement (GKA)}
\label{subsections:gka}

During the GKA sub-protocol the participants construct a shared secret key $\mathcal{K}$. The latter will be used in order for symmetric encryption keys to be derived.

The main idea is to compute a combined Diffie-Hellman-like key for all participants. To do this, each participant in the chatroom generates a private exponent. The shared base is then raised to this exponent. The key agreement begins by the initiating participant sending his public key to the next participant.

In each step that follows, the participant who just received a list of intermediate keys from the previous participant must calculate the next intermediate key list and forward it to the next participant. The forwarding procedure continues until the final participant has received an intermediate key list. During the $i$-th iteration, the corresponding participant receives keys from the $(i - 1)$th participant and then sends information to the $(i + 1)$th participant, as illustrated in figure \ref{figures:gka_upflow}. These messages shall be called "Upflow Messages".

When the last participant has received the required information, he computes a)the shared secret and b) the final intermediate key list. Then he broadcasts the final intermediate key list back to all previous participants, as illustrated in figure \ref{figures:gka_downflow}. This message, containing the final intermediate key list shall be called "Downflow Message".

The other participants now can also caclulate the shared secret using the final intermediate key list. Then, they can use it for encryption.

\begin{figure}[H]
  \begin{minipage}{0.49\textwidth}
    \begin{tikzpicture}[scale=.9]	
      \def \n {5}
      \def \ndec {4}
      \def \radius {3cm}
      \def \margin {8} % margin in angles, depends on the radius

      \foreach \s in {1,...,\ndec}
      {
        \node[draw, circle] at ({180 + (360/\n * (\s - 1))}:\radius) {$\s$};
        \draw[->, >=latex] ({145 + 36 + (360/\n * (\s - 1))+\margin}:\radius)
          arc ({145 + 36 + (360/\n * (\s - 1))+\margin}:{145 + 36 + 360/\n * (\s)-\margin}:\radius);
      }
      \node[draw, circle] at ({181 + 360/\n * (\n - 1)}:\radius) {$\n$};    
    \end{tikzpicture}
    \caption{This diagram demonstrates the upflow of the intermediate keys}    
    \label{figures:gka_upflow}
  \end{minipage}
  \begin{minipage}{0.49\textwidth}
    \begin{tikzpicture}[scale=.9]
      \def \n {5}
      \def \ndec {4}
      \def \radius {3cm}
      \def \margin {8} % margin in angles, depends on the radius

      \foreach \s in {1,...,\ndec}
      {
        \node[draw, circle](\s) at ({180 + (360/\n * (\s - 1))}:\radius) {$\s$};
      }
      \node[draw, circle](5) at ({181 + 360/\n * (\n - 1)}:\radius) {$\n$};
      \draw[->, >=latex] (5) -- (1);
      \draw[->, >=latex] (5) -- (2);
      \draw[->, >=latex] (5) -- (3);
      \draw[->, >=latex] (5) -- (4);
    \end{tikzpicture}
    \caption{This diagram demonstrates the downflow of the intermediate keys}
    \label{figures:gka_downflow}
  \end{minipage}
\end{figure}

\subsubsection{Detailed description}
For a more detailed description of the sub-protocol we refer to \cite{mpenc}, however a pseudocode is provided.

Algorithm \ref{upflow_algo} presents an overview of how each upflow message is constructed, using the data received from the previous upflow message.

Algorithm \ref{downflow_algo} presents an overview of how the final, downflow message is constructed using the data received from the last upflow message.

In algorithm \ref{gka_proto_algo} the two previous algorithms (\ref{upflow_algo} and \ref{downflow_algo}) are used in order to execute a complete run of the GKA protocol.

\begin{algorithm}[H]
	\KwIn{P : participants list}
	\KwExtraIn {InterKeys : previous intermediate key list}
	\KwExtraIn {X : user's secret key}
	\KwExtraIn {N : next participant}
	\KwResult{Sends the new intermediate key list to the next participant}
	\Begin{
	inter\_key\_list := empty\_list

	inter\_key\_list.append( InterKeys.last\_elem() )

	\ForEach{k in InterKeys}
	{
		inter\_key\_list.append( $k^X$ )
	}

	send( N , P || inter\_key\_list)
	}
	\caption{Upflow Message send algorithm}
	\label{upflow_algo}
\end{algorithm}

\begin{algorithm}[H]
	\KwIn{P : participants list}
	\KwExtraIn {InterKeys : previous intermediate key list}
	\KwExtraIn {X : user's secret key}
	\KwExtraIn {N : next participant}
	\KwResult{Sends the downflow intermediate key list to the other participants}
	\Begin{
	inter\_key\_list := empty\_list

	\ForEach{k in InterKeys}
	{
		inter\_key\_list.append( $k^X$ )
	}

	inter\_key\_list.reverse()

	send( N , P || inter\_key\_list)
	}
	\caption{Downflow Message send algorithm}
	\label{downflow_algo}
\end{algorithm}

\vfill
\begin{algorithm}[H]
	\KwIn{P : participants list}
	\KwOut{The shared secret}
	\KwResult{Executes a GKA and produces the shared secret}
	\Begin{

	prev := get\_previous\_participant()

	next := get\_next\_participant()

	x := gka\_genkey()

	\If{prev == NULL}{
		send\_upflow(P, [G], x, next)
		}
	\Else{
			m = receive\_from(prev)

			\If{ m not valid}{
					return error
			}
			\If{ next != NULL}{
				send\_upflow(P, m.key\_list, x, next)
			}
			\Else{
				final\_key := m.key\_list.last\_elem()

				s := $final\_key^x$

				send\_downflow(P, m.key\_list, x)

				return s
			}
	}

	m = wait\_for\_downflow()

	\If{m not valid}{
		return error
	}

	final\_key := m.key\_list[pos]

	s := $final\_key^x$

	return s

	}
	\caption{The GKA protocol}
	\label{gka_proto_algo}
\end{algorithm}

\subsection{Attest}
\label{subsections:attest}
During this sub-protocol the participants must verify that they agree on the $sid_i$ and the association table $\mathcal{S}$. This is needed for two reasons. First, because $sid_i$ is required before $\mathcal{S}$ is constructed, and therefore the messages exchanged for the calculation of $sid_i$ can't be signed. Second, because the participants need to verify that they all have the same view of $\mathcal{S}$.

Each participant calculates the SHA-512 hash of $\mathcal{S}$, which is sorted in lexicographical order according to each participant's username. Then they broadcast an authenticated message that contains both the $sid_i$ and the calculated hash.

To authenticate the message, each sender uses the ephemeral signing key she has now exchanged with the other participants. When each participant has received the attest messages from every other participant, she must check two things. First, she must verify that the hashes of $\mathcal{S}$ received from the other participants match the one she computed herself. Second, she must check that all participants have sent their messages using the same $sid_i$.

Provided that SHA-512 is a cryptographic hash function an attacker cannot find two signing keys association tables with the same hash. This means that he is not able to make two participants believe that they have arrived at the same table when they have not. Also by signing the message containing the specific $sid_i$, a user implicitly verifies that he is using that particular $sid_i$ for this session.

\subsection{Communication}
\label{subsections:communication}
Using the Communication sub-protocol, the participants can exchange authenticated and encrypted messages using the association table $\mathcal{S}$ derived from DSKE and the shared key $\mathcal{K}$ derived from GKA.

\subsubsection{Origin authentication}
For origin Authentication we use public key encryption methods. This is done because use of symmetric algorithms would require a participant who wishes to send a message to mac the message $n-1$ times, where $n$ is the number of the participants.

\paragraph{Algorithm}
While describing the DSKE we mentioned that an ephemeral signing key is transmitted by each participant to every other, to be used for message origin verification.

For this purpose we make use of the EdDSA algorithm. This algorithm was selected for its fast key generation, since a new keypair must be generated in each protocol run, and its relatively small signature size.

\paragraph{Signing}
\label{signing}
The signature generation is the last step taken before sending a message. This
way we can sign all the properties of the message to be sent, like the $sid$ or the
recipient (if any). We also avoid any manifestations of the Cryptographic Doom
Principle, which states that if a protocol tries to perform \emph{any}
cryptographic operation before verifying the signature or mac on a received
message, it will somehow fail catastrophically and lead to doom.

Symmetrically the signature verification is the first thing that happens before
any other operation is performed on the received message (cryptographic or not).

\subsubsection{Encryption}
For encryption a shared secret key $\mathcal{K}$ is used by all the members. This is not a problem since the origin authentication is provided by the signatures, and we obviously don't mind any chat member to read a message or we wouldn't participate in the chat in the first place. For the actual encryption we use AES-128 in CTR mode.

The use of the CTR mode however has a small pitfall. We must not let the same nonce be used twice. This is very difficult to achieve in a distributed setting like a multi-party chat protocol. Despite this we can solve the problem quite easily.

We maintain our original idea of a shared secret key, which we call master key, but we don't use it directly for encryption. Each participant uses the master key $\mathcal{K}$ and his id in the chatroom $ID_p$, in order to compute his "personal" encryption key $\mathcal{K}_e$. We define $ID_p$ as an unsigned integer indicating the position of $p$ in the ordered participants list. This encryption key for participant $p$ is derived as follows:

\[
    K_e = H(ID_p || Key_m)
\]

Provided that $H$ is a cryptographic hash function, an adversary cannot recover the value $\mathcal{K}_e$ used for encryption as long as he doesn't know the master key $\mathcal{K}$.

\subsubsection{Transcript}
In order for the shutdown sub-protocol to be executed we need to store the transcript of the chatroom. In reality a seperate transcript is held for the messages from each participant.
The shutdown protocol will then combine all the different transcripts to determine if consensus has been reached.

The transcripts are implemented as linked lists. Each list is kept sorted in lexicographic order.
When a message is to be added in a transcript list, the list is searched linearly to find the position the new message should be placed at.

When user $A$ sends a message, he adds that message to the transcript corresponding to himself.
When he receives a message from user $B$, he adds that message to the transcript corresponding to user $B$.

\subsection{Shutdown}
\label{subsections:shutdown}
During this sub-protocol, the participants end the current session. Chat room transcript consistency is checked and the ephemeral signing keys are published, in order to permit a posteriori modifications of the chat transcript. The revelation of the ephemeral signing keys adds to the protocol's deniability property. However, the protocol is deniable even without publishing the ephemeral signing keys, since the signing keys are deniable in the first place.

For a session to be terminated, a "Shutdown Message" is sent. This message signals to other participants that the shutdown phase should be initiated. It contains the  hash of all the messages sent by the user sending the "Shutdown Message". When a user receives a "Shutdown Message", he also responds with a "Shutdown Message" containing his own messages hash, if he hasn't already sent one.

When one participant has received a "Shutdown Message" from all other participants he can send a "Digest Message". This message contains a digest of all the messages in the chat room and is calculated as follows:
\begin{itemize}
  \item[] Sort the participants using their usernames in lexicographic order.
  \item[] For each participant $i$ (in that order) calculate the hash $h_i = H(S_i)$, where $S_i$ is set of all the messages sent by this user, sorted in lexicographic order too.
  \item[] Calculate the digest $h = H(h_1 || h_2 \dots || h_N)$, where N is the number of participants.
\end{itemize}

When one participant receives a "Digest Message" from some other participant, he checks whether the two of them agree on the chat room transcript. He simply compares the digest he computed locally to the one sent by the other participant. He deduces that consensus is reached only if the two digests are the same.

When one participant has received a "Digest Message" from every other participant, he broadcasts an "End Message". This message signifies that the sender will not use the channel to send any messages anymore.

When a participant receives an "End Message" from all other participants, he is certain that he can release his signing secret key. This is done by broadcasting a message which we shall call "Key Release Message". Now anyone who intercepts the released key can forge chat room messages. However all the participants will no longer accept messages signed with the released secret key, and thus it cannot be used to impersonate its previous owner.

\section{Participants ordering}
In many cases, the protocol demands some ordering of the participants. For example, in the Offer step of the Setup phase, the sid contributions should be concatenated in some order before hashing them. Same stands for the public signing keys in the association table, during the Attest step. So we define an ordering rule for the participants, that is used whenever an ordering of elements corresponding to participants is needed.

Given that the application provides the mpOTR protocol with a unique name describing each participant, we make the convention that every ordering of the participants list is made lexicographically based on that unique name. We also define the position of the participant, as his position in this order, starting counting from zero (0).

\section{Identity verification}
The identity of a participant is verified during the DSKE phase.
In order for a participant to be verified the fingerprint of his longterm key must be stored in the known fingerprints file, and be explicitly marked as verified.
In our implementation this file is comma separated and is of the form:

\begin{verbatim}
<account_name>,<protocol>,<buddy_name>,<fingerprint>,<is_verified>
\end{verbatim}

The account name is the "address" of the library user in the form username@host, and is provided by the application.
The protocol is a string that is characteristic of the underlying protocol that the specific account uses.
It is again provided by the application.
The buddy name is the nickname that a user is identified with.
For the time being it is the username part of a users "address".
This implies that the underlying protocol provides addresses which do not change often for a user.
It also means that users from multiple hosts are not allowed or else two users with the same username might conflict.
The above holds for a protocol like jabber for example, but is not the case for protocols like IRC.
As a result our implementation is not fully protocol agnostic at this moment.
Finally the fingerprint is the sha256 hash of the public identity key, and the last field is 1 if the key is verified and 0 otherwise.

This file is read during the plugin start up and initializes the list of all known fingerprints.
When a new chatroom is created, each participant is assigned a list with all known fingerprints used by this participant (from the above list).
When a "Handshake Message" is received the participants known fingerprints list is checked to find (if it exists) a fingerprint matching the currently used public key.
If such a fingerprint is found and it is verified, then the user is verified for this session.
If the found fingerprint is not verified then the participant is not verified.
If no key is found then again the participant is not verified and an entry for this new key is added in the known fingerprints list.

\section{Instance tags}
\label{subsections:instance_tags}
Many IM Protocols allow for a client to be logged into the same account from multiple locations and the server may relay messages to all of them. So, a distinguishing mechanism is required. We follow the same approach used in the version 3 of OTR, called instance tags.

Instance tags are 32-bit values that are intended to be persistent. If the same client is logged into the same account from multiple locations, the intention is that the client will have different instance tags at each location. All mpOTR messages include the sender's instance tag. 

\section{Data Types}
We present a list of several data types used in mpOTR messages along with their encoding:
\begin{description}[align=left]
\item [SHORT] Short integers. 2 byte unsigned value, big-endian.
\item [INT] Integers. 4 byte unsigned value, big-endian.
\item [MPI] Multi Precision Integers. 4 byte unsigned len, big-endian. len byte string with each byte of the MPI encoded as 2 hex digits. Negative numbers are prefix with a minus sign and in addition the high bit is always zero to make clear that an explicit sign ist used.
\item [LIST] Lists of any other type. 4 byte unsigned len, big-endian. len encoded list elements.
\item[HASH32] Hashes. 32 bytes of data.
\item[HASH64] Hashes. 64 bytes of data.
\item[CTR] AES CTR-mode counter value. 8 bytes data.
\item[DATA] Opaque variable-length data. 4 byte unsigned len, big-endian. len byte data.
\end{description}

\section{Message types}
\label{subsections:message_types}
There are 12 different types of mpOTR messages. Each message is indicated by a positive integer. We have reserved the zero value to indicate non-OTR messages. The list of these types along with the corresponding integer value is shown below:

\begin{description}[align=left]
  \item[0] Non-OTR Message
  \item[1] Offer Message
  \item[2] Handshake Message
  \item[3] Confirm Message
  \item[4] Key Message
  \item[5] Upflow Message
  \item[6] Downflow Message
  \item[7] Attest Message
  \item[8] Data Message
  \item[9] Shutdown Message
  \item[10] Digest Message
  \item[11] End Message
  \item[12] Key Release Message
\end{description}

\section{Message Structure}
All mpOTR messages start with the string "?OTR:" followed by the base64 encoded message and then a "." denoting the end of the message.

\subsection{General message structure}
In figure \ref{figures:general_message_structure} the general structure of mpOTR messages is shown.

\begin{figure}[H]
  \begin{bytefield}[bitwidth=0.11111\linewidth]{8}
    \bitheader{0-7} \\
    \begin{rightwordgroup}{Header}
      \bitbox{2}{PV} & \bitbox{2}{MT} & \bitbox{4}{Instance Tag} \\
      \wordbox{4}{Session ID}
    \end{rightwordgroup} \\
    \wordbox{4}{Payload} \\
    \wordbox{2}{Signature}
  \end{bytefield}  
  
  \caption{General message structure}
  \label{figures:general_message_structure}
\end{figure}

\begin{description}[align=left]
  \item[PV] Protocol Version. A SHORT indicating the Protocol Version the message is intended for.
  \item[MT] Message Type. A SHORT indicating the type of the message. See \ref{subsections:message_types} for more details.
  \item [Instance Tag] An INT indicating the instance tag. See \ref{subsections:instance_tags} for more details.
  \item[Session ID] A HASH64 containing the value of $sid_i$. Not existent in Offer Messages.
  \item[Payload] Specific data dependent for each type of message. See \ref{subsections:payload_structures} for more details.
  \item[Signature] The signature covering all data above, used to authenticate the message. Not existent in all message types.
\end{description}

Offer Messages contain no Session ID in the header, since $sid_i$ has not been established yet. Offerand DAKE Messages contain no Signature since the association table $\mathcal{S}$ has not been constructed yet. Shutdown KeyRelease Messages contain no Signature since authentication is not required.

\subsection{Payload structures}
\label{subsections:payload_structures}

\subsubsection{Offer message payload}
\begin{figure}[H]
  \begin{bytefield}[bitwidth=0.11111\linewidth]{8}
    \bitheader{0-7} \\
    \bitbox{4}{Position} & \bitbox[lrt]{4}{} \\
    \wordbox[lr]{1}{SID Contribution} \\
    \bitbox[l]{4}{} & \bitbox[rb]{4}{} \\
    \bitbox[lrb]{4}{}
  \end{bytefield}
  \caption{The structure of Offer Message payload}
\end{figure}

\begin{description}[align=left]
  \item[Position] An INT indicating the sender's position in the ordered list of the participants.
  \item[SID Contribution] A HASH32 containing the sender's contribution for the construction of the $sid_i$.
\end{description}

\subsubsection{Handshake Message Payload}
\begin{figure}[H]
  \begin{bytefield}[bitwidth=0.11111\linewidth]{8}
    \bitheader{0-7} \\
    \wordbox[lrt]{1}{Ephemeral PubKey} \\
    \wordbox[blr]{1}{$\cdots$} \\
    \wordbox[lrt]{1}{Longterm PubKey} \\
    \wordbox[blr]{1}{$\cdots$}
  \end{bytefield}
  \caption{The structure of Handshake Message payload}
\end{figure}

\begin{description}[align=left]
  \item[Ephemeral PubKey] A MPI containing the public part of the ephemeral key.
  \item[Longterm PubKey] A MPI containing the public part of the longterm key.
\end{description}

\subsubsection{Confirm Message Payload}
\begin{figure}[H]
  \begin{bytefield}[bitwidth=0.11111\linewidth]{8}
    \bitheader{0-7} \\
    \bitbox{4}{Recipient} & \bitbox[tlr]{4}{} \\
    \wordbox[lr]{1}{TDH MAC} \\
    \bitbox[l]{4}{} & \bitbox[rb]{4}{} \\
    \bitbox[lrb]{4}{}
  \end{bytefield}
  \caption{The structure of Confirm Message payload}
\end{figure}

\begin{description}[align=left]
  \item[Recipient] An INT indicating the participant this message is intended for. It's actually his position in the ordered participants list.
  \item[TDH MAC] Triple Diffie-Hellman MAC. A HASH32 containing the MAC value for a magic number.
\end{description}

\subsubsection{Key Message Payload}
\begin{figure}[H]
  \begin{bytefield}[bitwidth=0.11111\linewidth]{8}
    \bitheader{0-7} \\
    \bitbox{4}{Recipient} & \bitbox[tlr]{4}{} \\
    \wordbox[lr]{1}{TDH MAC} \\
    \bitbox[l]{4}{} & \bitbox[rb]{4}{} \\
    \bitbox[lrb]{4}{} & \bitbox[tlr]{4}{} \\
    \wordbox[lr]{1}{Key} \\
    \wordbox[blr]{1}{$\cdots$} \\
  \end{bytefield}
  \caption{The structure of Key Message payload}
\end{figure}

\begin{description}[align=left]
  \item[Recipient] An INT indicating the participant this message is intended for. It's actually his position in the ordered participants list.
  \item[TDH MAC] Triple Diffie-Hellman MAC. A HASH32 containing the MAC value for the following key.
  \item[Key] The encrypted public part of the ephemeral signing key.
\end{description}

\subsubsection{Upflow Message Payload}
\begin{figure}[H]
  \begin{bytefield}[bitwidth=0.11111\linewidth]{8}
    \bitheader{0-7} \\
    \bitbox{4}{Recipient} & \bitbox{4}{ListLen} \\
    \begin{rightwordgroup}{\parbox{4em}{\raggedright ListLen number of list elements}}
      \wordbox[lrt]{1}{1st Key} \\
      \wordbox[blr]{1}{$\cdots$} \\
      \wordbox[lrt]{1}{2nd Key} \\
      \wordbox[blr]{1}{$\cdots$} \\
      \wordbox[blr]{2}{$\cdots$} \\
      \wordbox[lrt]{1}{n-th Key} \\
      \wordbox[blr]{1}{$\cdots$}
    \end{rightwordgroup}
  \end{bytefield}
  \caption{The structure of Upflow Message payload}
\end{figure}

\begin{description}[align=left]
  \item[Recipient] An INT indicating the participant this message is intended for. It's actually his position in the ordered participants list.
  \item[ListLen] An INT containing the length of the following key list.
  \item[i-th Key] An MPI containing the i-th key of the intermediate key list.
\end{description}

\subsubsection{Downflow Message Payload}
\begin{figure}[H]
  \begin{bytefield}[bitwidth=0.11111\linewidth]{8}
    \bitheader{0-7} \\
    \begin{rightwordgroup}{\parbox{4em}{\raggedright ListLen number of list elements}}
      \bitbox{4}{ListLen} & \bitbox[tlr]{4}{} \\
      \wordbox[lr]{1}{1st Key} \\
      \wordbox[blr]{1}{$\cdots$} \\
      \wordbox[lrt]{1}{2nd Key} \\
      \wordbox[blr]{1}{$\cdots$} \\
      \wordbox[blr]{2}{$\cdots$} \\
      \wordbox[lrt]{1}{n-th Key} \\
      \wordbox[blr]{1}{$\cdots$}
    \end{rightwordgroup}
  \end{bytefield}
  \caption{The structure of Downflow Message payload}
\end{figure}

\begin{description}[align=left]
  \item[ListLen] An INT containing the length of the following key list.
  \item[i-th Key] An MPI containing the i-th key of the intermediate key list.
\end{description}

\subsubsection{Attest Message Payload}
\begin{figure}[H]
  \begin{bytefield}[bitwidth=0.11111\linewidth]{8}
    \bitheader{0-7} \\
    \wordbox{2}{Session ID} \\
    \wordbox{2}{Association Table Hash} 
  \end{bytefield}
  \caption{The structure of Attest Message payload}
\end{figure}

\begin{description}[align=left]
  \item[Session ID] An HASH64 containing the value of $sid_i$.
  \item[Association Table Hash] An HASH64 containing the hash of the association table $\mathcal{S}$.
\end{description}

\subsubsection{Data Message Payload}
\begin{figure}[H]
  \begin{bytefield}[bitwidth=0.11111\linewidth]{8}
    \bitheader{0-7} \\
    \wordbox{1}{CTR} \\
    \wordbox[tlr]{1}{Ciphertext} \\
    \wordbox[blr]{1}{$\cdots$} \\
  \end{bytefield}
  \caption{The structure of Data Message payload}
\end{figure}

\begin{description}[align=left]
  \item[CTR] A CTR. The top half of the counter for AES CTR-mode.
  \item[Ciphertext] DATA. The encrypted message.
\end{description}

\subsubsection{Shutdown Message Payload}
\begin{figure}[H]
  \begin{bytefield}[bitwidth=0.11111\linewidth]{8}
    \bitheader{0-7} \\
    \wordbox{2}{Shutdown Hash} \\
  \end{bytefield}
  \caption{The structure of Shutdown Message payload}
\end{figure}

\begin{description}[align=left]
  \item[Shutdown Hash] A HASH64 containing the hash of the sender's transcript.
\end{description}

\subsubsection{Digest Message Payload}
\begin{figure}[H]
  \begin{bytefield}[bitwidth=0.11111\linewidth]{8}
    \bitheader{0-7} \\
    \wordbox{2}{Digest} \\
  \end{bytefield}
  \caption{The structure of Digest Message payload}
\end{figure}

\begin{description}[align=left]
  \item[Digest] A HASH64 containing the hash of all transcripts.
\end{description}

\subsubsection{End Message Payload}
An End Message contains no payload.

\subsubsection{Key Release Message Payload}
\begin{figure}[H]
  \begin{bytefield}[bitwidth=0.11111\linewidth]{8}
    \bitheader{0-7} \\
    \wordbox[tlr]{1}{Key} \\
    \wordbox[blr]{1}{$\cdots$} \\
  \end{bytefield}
  \caption{The structure of Key Release Message payload}
\end{figure}

\begin{description}[align=left]
  \item[Key] DATA. The value of the key to be revealed.
\end{description}