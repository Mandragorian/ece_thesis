\chapter{Implementation}
\label{chapter:implementation}

%--------------------------------------------

\section{Summary}
Our primary goal was to design and implement the protocol we specified as a production-grade software, aiming to meet the needs of a wide user base. Of course every user would expect of such a software to offer privacy in communication between two parties too. That said, implementing mpOTR as part of the OTR library was a natural decision. Not only would this result in a complete IM privacy library, but it would, as well, affect an already existing wide user base.

There exist quite a few implementations of the OTR Library, but only two of them have been actually developed by the OTR Development Team. The first one is implemented in C, it's the very first implementation and the most actively developed having 4 major versions with latest release in March of 2016. The other one is implemented in Java, and has only one release in October of 2009. We chose to develop mpOTR as part of the C implementation of the OTR Library.


\section{Designing the Integration}
Integrating a new feature into an existing software is quite a challenge. Ideally, a good design would at least follow the same coding style, make the best possible reuse of the existing code and follow the same design patters. However, after a carefull inspection of the OTR Library source code we realized that following this approach was unfeasible.

First of all, the coding style in OTR Librady source code is inconsistent. Different characters have been used for indentation, there is no standard error handling style, etc. Reusing parts of the existing code was not an option most of the time due to extensive coupling between the various modules. Finally, no specific design patterns had been used in the existing code.

Our approach was rather different. First, we used the coding style used more frequently in the existing code. The code reuse was limitted to the Diffie-Hellman and Base64 implementations that were the only reusable modules of the existing code. As for the design patterns, we decided to use them based on theory.


\section{Design Challenges in C}
A great deal of the callenges a software engineer is going to face when designing a software to be developed in C origins in the lack of literature regarding the Design Patterns. Most of the relative literature, such as the commonly referenced \cite{gofdesignpatterns}, describe the actual implementations of the patterns in the context of an object oriented design.

Given that C is not object oriented language, a developer should be innovative when implementing commonly used design patterns. Fortunately, C is a powerfull language offering the mechanisms to implement almost any design pattern. This power mainly comes from two features, the ability to specify incomplete types in order to achieve abstraction in the sense of information hiding, and the use of \textit{void*} in order to achieve generality as interface and inheritence would do in an object oriented context. The latter must be used carefully, since it could raise the risks regarding type-safety.

The most complete reference of design patterns in C can be found in \cite{patternsinc}. Although it only covers a small number of patterns, it equips the reader with a clear approach of designing patterns when object-oriented techniques are not natively supported by the language. We also used \cite{patternsinc} as a reference for various patterns we implemented.


\section{Design Patterns}
In this section we describe the Design Patterns we utilized in our implementation.

\subsection{First-Class ADT}
First-Class ADT is a pattern that decouples interface from implementation, thus improving encaplulation and providing loose dependencies. We get a definition from \cite{patternsinc}:
\begin{quote}
ADT stands for Abstract Data Type and it is basically a set of values and operations on these values. The ADT is considered first-class if we can have many, unique instances of it.
\end{quote}

Our implementation of First-Class ADTs is based on the paradigm found in \cite{patternsinc}.

The header file of each First-Class ADT contains the declaration of a pointer to an incomplete type and the declaration of all functions that the interface constists of. The source file of each First-Class ADT contains the definition of the incomplete type, as a structure and the definition of each interface function.

Instances of the declared pointer serve as a handle for the clients. This mechanism enforces the clients to use the provided interface functions rather than directly accessing the fields of the structure.

We implemented most of the infrastructure modules as First-Class ADTs, namely \textit{ChatParticipant}, \textit{ChatContext}, \textit{ChatEvent}, \textit{ChatParticipant} and other.

\subsection{Observer}
PLACEHOLDER

\subsection{Iterator}
PLACEHOLDER

\section{Idiomatic Expressions}
Idiomatic expressions, also reffered to as idioms, are low-level patterns that depend upon the implementation technology. Usually idioms are only applicable in a specific language.

\subsection{Constants to the left}
The C language allows assignments inside conditional statement. This can be convenient in various cases, but can also lead to serious bugs when a programmer accidentaly uses the assignment symbol instead of the comparison symbol, as in the following example:
\begin{lstlisting}[language=C]
if(x = 0) {
    /* This will never be true */
}
\end{lstlisting}

By keeping constants to the left in comparisons the compiler will catch an erroneous assignment. So, a correct conditional statement using the idiom looks like:
\begin{lstlisting}[language=C]
if(0 == x) {
    /* Control will get here if x is zero */
}
\end{lstlisting}


\subsection{Sizeof to variables}
When using functions for dynamic memory allocation in the C language the client has to provide the required size information. Many programmers use to dynamically allocate memory as in the following example:
\begin{lstlisting}[language=C]
  OneType* var = malloc(sizeof(OneType));
\end{lstlisting}

Code like this contains a subtle form of dependency, that is the size given as an argument of malloc must match the size of the left sife of the assignment. A change in the variable type requires a change in two places. A failure to update both places would leave the code with undefined behaviour.

By applying \textit{sizeof} to variables the dependency is removed and the change is limited to one place. When the idiom is applied the code will look like this:
\begin{lstlisting}[language=C]
  OneType* var = malloc(sizeof *var);
\end{lstlisting}

\section{Design Model}
PLACEHOLDER

\section{Application Programming Interface}

\subsection{The \emph{OtrlUserState} instance handle}
The OTR library uses a handle to associate internal protocol data with the client. This is a variable of type \emph{OtrlUserState}. We used this handle to associate mpOTR Protocol internal data, too. Regarding the mpOTR implementation, it encapsulates the list of private identity keys, the list of known fingerprints and a list of mpOTR session descriptors. The \emph{OtrlUserState} instance handle will be passed as an argument to various mpOTR library API endpoints.

Most clients will only need one instance handle, but in a case of a client implementing a multi-user context there may be the need for more instance handles.

The following functions are provided to create a new handle and to free an already created \emph{OtrlUserState}:
\begin{lstlisting}[caption={OtrlUserState interface}]
OtrlUserState otrl_userstate_create(void);
void otrl_userstate_free(OtrlUserState us);
\end{lstlisting}
The client should free every created \emph{OtrlUserState} handle when he is finished with them.

\subsection{The \emph{otrl\_chat\_token\_t} chat room identifier}
When the client wants to call chat room specific library functions, it should provide a value that identifies the specific chat room. The client should assure that only one chat room corresponds to a specific value and vice versa. We call this type of value \emph{otrl\_chat\_token\_t} which is defined:
\begin{lstlisting}[caption={otrl\_chat\_token\_t definition}]
typedef int otrl_chat_token_t;
\end{lstlisting}

\subsection{The \emph{OtrlChatInfoPtr} chat room descriptor}
\emph{OtrlChatInfoPtr} is a First-Class ADT used to encapsulate information about a specific chat room. The following interface is provided for the client:
\begin{lstlisting}[caption={OtrlChatInfoPtr First-Class ADT interface}]
char * otrl_chat_info_get_accountname(OtrlChatInfoPtr info);
char * otrl_chat_info_get_protocol(OtrlChatInfoPtr info);
otrl_chat_token_t otrl_chat_info_get_chat_token(OtrlChatInfoPtr info);
OtrlChatPrivacyLevel otrl_chat_info_get_privacy_level(OtrlChatInfoPtr info);
\end{lstlisting}

The \emph{OtrlChatPrivacyLevel} is defined as follows:
\begin{lstlisting}[caption={OtrlChatPrivacyLevel definition}]
typedef enum {
	OTRL_CHAT_PRIVACY_LEVEL_NONE,
	OTRL_CHAT_PRIVACY_LEVEL_UNVERIFIED,
	OTRL_CHAT_PRIVACY_LEVEL_PRIVATE,
	OTRL_CHAT_PRIVACY_LEVEL_FINISHED,
	OTRL_CHAT_PRIVACY_LEVEL_UNKNOWN
} OtrlChatPrivacyLevel;
\end{lstlisting}

\subsection{The \emph{OtrlMessageAppOps} callbacks structure}
\label{section:callbacks_structure}
In order for a client to use OTR Library, it must provide a structure containing pointers to functions that must be defined by the client but called by the library. The type of structure is called \emph{OtrlMessageAppOps}. We added callbacks needed for mpOTR in this structure, too. Regarding the mpOTR implementation the following callbacks were added:

\begin{lstlisting}[caption={mpOTR callbacks in OtrlMessageAppOps}]
int (*chat_inject_message)(void *opdata, const OtrlChatInfoPtr info, const char *message);
void (*chat_handle_event)(void *odata, const OtrlChatInfoPtr info, const OtrlChatEventPtr event);
void (*chat_display_notification_cb)(void *opdata, const OtrlChatInfoPtr info, const char *notification);
char **(*chat_get_participants)(void *opdata, const OtrlChatInfoPtr info, unsigned int *size);
void (*chat_privkey_create)(void *opdata, const char *accountname, const char *protocol);
void (*chat_fingerprints_write)(void *opdata);
void (*chat_privkeys_write)(void *opdata);
void (*chat_info_refresh)(void *opdata, const OtrlChatInfoPtr info);
\end{lstlisting}

\begin{description}
  \item \emph{chat\_inject\_message}: Broadcasts \emph{message} to the chatroom defined by \emph{info}. Returns \emph{0} on success, non-zero on error.

  \item \emph{chat\_handle\_event}: Reacts to \emph{event} that happened in the chatroom defined by \emph{info}. The events are described in section \ref{section:events}.

  \item \emph{chat\_display\_notification\_cb}: Displays \emph{notification} regarding the chatroom defined by \emph{info}.
  
  \item \emph{chat\_get\_participants}: Provides the list of the participants' usernames that are currently in the chatroom defined by \emph{info}. Returns a pointer to an array of the usernames along with the number of participants in the output parameter \emph{*size} on success, \emph{NULL} on error.
    
  \item \emph{chat\_privkey\_create}: Invokes the library's function that creates a new private key for this \emph{accountname} and \emph{protocol}, providing it with the proper file descriptor. The invoked function is described in \ref{section:private_key_management}.

  \item \emph{chat\_fingerprints\_write}: Invokes the library's function that writes the known fingerprints to a file, providing it with the proper file descriptor. The invoked function is described in section \ref{section:fingerprint_management}.
  
  \item \emph{chat\_privkeys\_write}: Invokes the library's function that writes the private identity keys to a file, providing it with the proper file descriptor. The invoked function is described in \ref{section:private_key_management}.

  \item \emph{chat\_info\_refresh}: Reacts to a change regarding the status of the chatroom defined by \emph{info}.
  
\end{description}

\subsection{Starting private session}
To start a private session the client should use:
\begin{lstlisting}[caption={The private session initiation function}]
int otrl_chat_protocol_send_query(OtrlUserState us, const OtrlMessageAppOps *ops, const char *accountname, const char *protocol, otrl_chat_token_t chat_token);
\end{lstlisting}

The following parameters should be provided:
\begin{description}
  \item \emph{us}: The instance handle.
  \item \emph{ops}: The callbacks structure.
  \item \emph{accountname}: The identifying name for the account in use.
  \item \emph{protocol}: The identifying name for the protocol in use.
  \item \emph{chat\_token}: The chat room identifier.
\end{description}

\subsection{Ending a private session}
To end a private session the client should use:
\begin{lstlisting}[caption={The private session ending function}]
int otrl_chat_protocol_shutdown(OtrlUserState us, const OtrlMessageAppOps *ops, const char *accountname, const char *protocol, otrl_chat_token_t chat_token);
\end{lstlisting}

The following parameters should be provided:
\begin{description}
  \item \emph{us}: The instance handle.
  \item \emph{ops}: The callbacks structure.
  \item \emph{accountname}: The identifying name for the account in use.
  \item \emph{protocol}: The identifying name for the protocol in use.
  \item \emph{chat\_token}: The chat room identifier.
\end{description}

\subsection{Handling messages}
Since the client knows nothing about active mpOTR sessions and the structure of mpOTR messages, it should pass every message to mpOTR functions before sending or after receiving them. The mpOTR will decide if they should be handled by the library or not. The following two functions are provided. 

Upon receiving a message in a chatroom and before displaying it to the user the client application should call:
\begin{lstlisting}[caption={The received messages handling function}]
int otrl_chat_protocol_receiving(OtrlUserState us, const OtrlMessageAppOps *ops, void *opdata, const char *accountname, const char *protocol, const char *sender, otrl_chat_token_t chat_token, const char *message, char **newmessagep);
\end{lstlisting}

The following parameters should be provided:
\begin{description}
  \item \emph{us}: the instance handle
  \item \emph{ops}: the callbacks structure
  \item \emph{opdata}: 
  \item \emph{accountname}: the identifying name for the account in use
  \item \emph{protocol}: the identifying name for the protocol in use
  \item \emph{sender}: the username of the message sender
  \item \emph{chat\_token}: the chat room identifier
  \item \emph{message}: the received message
  \item \emph{*newmessagep}: output parameter that contains contains a newly allocated string that should be displayed to the user instead of message, or \emph{NULL} if no modification is needed.
\end{description}
If \emph{0} is returned, \emph{message} was an ordinary, non-OTR message, which should be delivered to the user without modification. If \emph{1} is returned, the message was handled by mpOTR library. In this case, if \emph{*newmessagep} is \emph{NULL} then nothing should be displayed to the user. Else \emph{*newmessagep} should be displayed to the user intead of the received one and be freed afterwards.

Before sending a user's message the client application should call:
\begin{lstlisting}[caption={The sending messages handling function}]
int otrl_chat_protocol_sending(OtrlUserState us, const OtrlMessageAppOps *ops, void *opdata, const char *accountname, const char *protocol, const char *message, otrl_chat_token_t chat_token, char **messagep);
\end{lstlisting}

The following parameters should be provided:
\begin{description}
  \item \emph{us}: the instance handle
  \item \emph{ops}: the callbacks structure
  \item \emph{opdata}: 
  \item \emph{accountname}: the identifying name for the account in use
  \item \emph{protocol}: the identifying name for the protocol in use
  \item \emph{sender}: the username of the message sender
  \item \emph{message}: the message to be sent
  \item \emph{chat\_token}: the chat room identifier
  \item \emph{*messagep}: output parameter that contains contains a newly allocated string that should be sent instead of \emph{message}, or \emph{NULL} if no modification is needed.
\end{description}
Returns a non-zero in case of error. In this case, nothing is safe to be sent. If \emph{0} is returned then the client should check \emph{*messagep}. If \emph{*messagep} is \emph{NULL} then \emph{message} should be sent unmodified. Else \emph{*messagep} should be sent to the chat room intead of \emph{message} and be freed afterwards.

\subsection{Private identity key management}
\label{section:private_key_management}
The following functions are provided for the management of the private identity keys:
\begin{lstlisting}[caption={Private identity key management functions}]
int otrl_chat_protocol_id_key_read_file(OtrlUserState us, FILE *privf);
int otrl_chat_protocol_id_keys_write_file(OtrlUserState us, FILE *privf);
int otrl_chat_protocol_id_key_generate_new(OtrlUserState us, const OtrlMessageAppOps *ops, const char *accountname, const char *protocol);
OtrlListPtr otrl_chat_protocol_id_key_list_create(OtrlUserState us);
**messagep);
\end{lstlisting}

\begin{description}
  \item \emph{otrl\_chat\_protocol\_id\_key\_read\_file}: Loads the private identity key list from the specified file to the memory. It should be called once before using the mpOTR Library for instance handle \emph{us}.
  
  \item \emph{otrl\_chat\_protocol\_id\_keys\_write\_file}: Writes the private identity key list loaded in the memory, to the specified file. It is meant to be called only inside the proper callback function, see section \ref{section:callbacks_structure}.
  
  \item \emph{otrl\_chat\_protocol\_id\_key\_generate\_new}: Creates a new private identity key for the specified \emph{accountname} and \emph{protocol}.
  
  \item \emph{otrl\_chat\_protocol\_id\_key\_list\_create}: Creates and returns a list containing elements of type \emph{OtrlChatIdKeyInfoPtr}. Each element contains information about each private identity key.

\end{description}

The structure pointer \emph{OtrlChatIdKeyInfoPtr} is defined as follows:
\begin{lstlisting}[caption={OtrlChatIdKeyInfoPtr definition}]
typedef struct OtrlChatIdKeyInfo * OtrlChatIdKeyInfoPtr;

struct OtrlChatIdKeyInfo {
	char *accountname;
	char *protocol;
	char *fingerprint_hex;
};
\end{lstlisting}

\subsection{The \emph{OtrlChatFingerprintPtr} Frist-Class ADT}
The fingerprints are implemented as First-Class ADT. The following interface is provided:

\begin{lstlisting}[caption={OtrlChatFingerprintPtr Frist-Class ADT interface}]
char *otrl_chat_fingerprint_bytes_to_hex(const unsigned char *fingerprint);
size_t chat_fingerprint_size();
char * otrl_chat_fingerprint_get_accountname(OtrlChatFingerprintPtr fnprnt);
char * otrl_chat_fingerprint_get_protocol(OtrlChatFingerprintPtr fnprnt);
char * otrl_chat_fingerprint_get_username(OtrlChatFingerprintPtr fnprnt);
unsigned char * otrl_chat_fingerprint_get_bytes(OtrlChatFingerprintPtr fnprnt);
\end{lstlisting}

\begin{description}
  \item \emph{otrl\_chat\_fingerprint\_bytes\_to\_hex}: Converts fingerprint bytes to human-readable form. The result should be freed by the caller.
  
  \item \emph{otrl\_chat\_fingerprint\_get\_accountname}: Returns the username of the user that knows this fingerprint.
  
  \item \emph{otrl\_chat\_fingerprint\_get\_protocol}: Returns the protocol used when this fingerprint was met.
  
  \item \emph{otrl\_chat\_fingerprint\_get\_username}: Returns the username of the user who has an identity key with that fingerprint.
  
  \item \emph{otrl\_chat\_fingerprint\_get\_bytes}: Returns the actual bytes of the fingerprint.

\end{description}

\subsection{Known fingerprints management}
\label{section:fingerprint_management}
The following functions are provided regarding the management of the known fingerprints:
\begin{lstlisting}[caption={Known fingerprints management functions}]
int otrl_chat_protocol_fingerprints_read_file(OtrlUserState us, FILE *fingerfile);
int otrl_chat_protocol_fingerprints_write_file(OtrlUserState us, FILE *fingerfile);
void otrl_chat_protocol_fingerprint_verify(OtrlUserState us, const OtrlMessageAppOps *ops, OtrlChatFingerprintPtr fnprnt);
void otrl_chat_protocol_fingerprint_forget(OtrlUserState us, const OtrlMessageAppOps *ops, OtrlChatFingerprintPtr fnprnt);
\end{lstlisting}

\begin{description}
  \item \emph{otrl\_chat\_protocol\_fingerprints\_read\_file}: Loads the known fingerprints list from the specified file to the memory. It should be called once before using the mpOTR Library for instance handle \emph{us}.
  
  \item \emph{otrl\_chat\_protocol\_fingerprints\_write\_file}: Writes the known fingerprints list loaded in the memory, to the specified file. It is meant to be called only inside the proper callback function, see section \ref{section:callbacks_structure}.
  
  \item \emph{otrl\_chat\_protocol\_fingerprint\_verify}: Marks the specified fingerprint as verified.
  
  \item \emph{otrl\_chat\_protocol\_fingerprint\_forget}: Removes the specified fingerprint from the known fingerprints list.

\end{description}

\subsection{Events}
\label{section:events}
Events are implemented as a First-Class ADT called \emph{OtrlChatEventDataPtr}. The following interface is provided:
\begin{lstlisting}[caption={OtrlChatEventDataPtr First-Class ADT interface}]
OtrlChatEventType otrl_chat_event_get_type(OtrlChatEventPtr event);
OtrlChatEventDataPtr otrl_chat_event_get_data(OtrlChatEventPtr event);
\end{lstlisting}

\begin{description}
  \item \emph{otrl\_chat\_event\_get\_type}: Returns an \emph{OtrlChatEventType} indicating the type of the event.
  
  \item \emph{otrl\_chat\_event\_get\_data}: Returns the type specific data of the event if any, else returns NULL.
    
\end{description}

\subsubsection{Event types}

The following event types are defined:
\begin{lstlisting}[caption={OtrlChatEventType definition}]
typedef enum {
	OTRL_CHAT_EVENT_OFFER_RECEIVED,
	OTRL_CHAT_EVENT_STARTING,
	OTRL_CHAT_EVENT_STARTED,
	OTRL_CHAT_EVENT_UNVERIFIED_PARTICIPANT,
	OTRL_CHAT_EVENT_PLAINTEXT_RECEIVED,
	OTRL_CHAT_EVENT_PRIVATE_RECEIVED,
	OTRL_CHAT_EVENT_CONSENSUS_BROKEN,
	OTRL_CHAT_EVENT_FINISHED	
} OtrlChatEventType;
\end{lstlisting}
\begin{description}
  \item \emph{OTRL\_CHAT\_EVENT\_OFFER\_RECEIVED}: Emitted when we received an offer. Contains intenal data of type \emph{OtrlChatEventParticipantDataPtr}.
  
  \item \emph{OTRL\_CHAT\_EVENT\_STARTING}: Emitted when the protocol attempts to start a private session. Contains no internal data.
  
  \item \emph{OTRL\_CHAT\_EVENT\_STARTED}: Emitted when the private session has started. Contains no internal data.
  
  \item \emph{OTRL\_CHAT\_EVENT\_UNVERIFIED\_PARTICIPANT}: Emitted when the private session has started with an unverified participant in it. Contains intenal data of type \emph{OtrlChatEventParticipantDataPtr}.
  
  \item \emph{OTRL\_CHAT\_EVENT\_PLAINTEXT\_RECEIVED}: Emitted when we receive a plaintext message while in a private session. Contains intenal data of type \emph{OtrlChatEventMessageDataPtr}.
  
  \item \emph{OTRL\_CHAT\_EVENT\_PRIVATE\_RECEIVED}: Emitted when we receive a private message while NOT in a private session. Contains intenal data of type \emph{OtrlChatEventParticipantDataPtr}.
  
  \item \emph{OTRL\_CHAT\_EVENT\_CONSENSUS\_BROKEN}: Emitted when there was no consensus with a participant. Contains intenal data of type \emph{OtrlChatEventParticipantDataPtr}.
  
  \item \emph{OTRL\_CHAT\_EVENT\_FINISHED}: Emitted when a private session was finished. Contains no internal data.

\end{description}

\subsubsection{Internal event data}
There are two different types of internal event data implemeneted as First-Class ADTs.

The first one is the \emph{OtrlChatEventParticipantDataPtr} with the following interface:
\begin{lstlisting}[caption={OtrlChatEventDataPtr First-Class ADT interface}]
char * otrl_chat_event_participant_data_get_username( OtrlChatEventParticipantDataPtr data);
\end{lstlisting}

The second one is the \emph{OtrlChatEventMessageDataPtr} with the following interface:
\begin{lstlisting}[caption={OtrlChatEventDataPtr First-Class ADT interface}]
char * otrl_chat_event_message_data_get_username( OtrlChatEventMessageDataPtr data);
char * otrl_chat_event_message_data_get_message( OtrlChatEventMessageDataPtr data);
\end{lstlisting}